import StateMachine from 'javascript-state-machine';
import _ from 'lodash';
import { v4 as uuidv4 } from 'uuid';

/**
 * game.
 */
export class GameState {
    name: any
    _stateMachine: StateMachine;
    designer: any;
    parent: any
    data: any
    states: {}
    children: any
    devices: any
    actions: Action[]
    deviceIds: any
    state: string

    constructor(gameplayConfig, parent) {
        this.name = gameplayConfig.name || 'Unnamed';
        this.parent = parent;

        this.updateStateMachine(gameplayConfig.states);

        this.data = gameplayConfig.data || {};
        this.designer = gameplayConfig.designer || {
            visible: true
        };

        this.children = Object.entries(gameplayConfig.children || {}).map((cEntry) => {
            return new GameState(cEntry[1], this);
        });
        for (let stateEntry of Object.entries(GameState._makeObj(this.states))) {
            let sBody : any = stateEntry[1];
            Object.entries(sBody.devices || {}).forEach((ent : any) => ent[1].id = uuidv4());
            // sBody.isActive = () => {
            //     return this.isActive() && this.state === stateEntry[0]
            // };
            sBody.children = Object.entries(GameState._makeObj(sBody.children)).map((cEntry) => {
                return new GameState(cEntry[1], sBody);
            });
        }

        this.devices = gameplayConfig.devices || {};
        Object.entries(this.devices || {}).forEach((ent : any) => ent[1].id = uuidv4());

        this.actions = (gameplayConfig.actions || []).map((actionConfig) => new Action(actionConfig));
        // this.wrapActions(this.actions);
        // Object.values(this.states).forEach((s : any) => this.wrapActions(s.actions));

        // output devices[] lamps, coils, relays, sounds, displays
        // input devices[] switches
        // state actions, handled first, can bubble?, depth first: state transition, function
        // actions: state transition, function
        // state data
        // machine data

        // each game loop queries depth first the state of output devices until all output devices
        // are checked. thus prefers specific behaviour over general behavoiur and returns to general
        // behaviour when state exits

        // gameStateEvents.on('goto', (event) => {
        //     // this._stateMachine.goto(event);
        //     console.log(this._stateMachine.allStates());
        // });
    }

    updateStateMachine(stateConfig = this.states) {
        const states = {};
        const initEntry = Object.entries(stateConfig || {}).find((entry : any) => entry[1].init);
        const initState = initEntry ? initEntry[0] : undefined;
        const cc = {
            init: initState,
            methods: {
                onLeaveState: (transition) => this.onLeaveState(transition),
            },
            transitions: Object.entries(stateConfig || {})
            // TODO: Add filter and fix tests.
                // .filter((ent) => ent[1].to)
                .map((entry) => {
                    const entryName = entry[0];
                    const state : any = entry[1];
                    const newState = new State(entry[0], state.init, state.to, state.devices, state.actions, state.data, state.children, state.designer);
                    states[entryName] = newState;
                    return {name: `to${newState.to}`, from: newState.name, to: newState.to};
                })
                .concat([
                    {name: 'reset', from: '*', to: initState}
                ])
        };
        this._stateMachine = new StateMachine(cc);
        this.states = states;
    }

    isActive() {
        if (!this.parent) {
            return true;
        }

        if (this.parent.isActive) {
            return this.parent.isActive();
        }
        else {
            return false;
        }
    }

    isStateActive(stateName) {
        return this._stateMachine.state === stateName;
    }

    getAllDeviceStates() {
        this.deviceIds = new Set();
        GameState._addToDeviceSet(this.deviceIds, this);
        return Array.from(this.deviceIds);
    }

    static _addToDeviceSet(set, obj) {
        for (const deviceId of Object.keys(obj.devices || {})) {
            set.add(deviceId);
        }

        const activeState = obj.getActiveStateObj ? obj.getActiveStateObj() : null;
        if (activeState) {
            GameState._addToDeviceSet(set, activeState);
        }

        for (const child of obj.children || []) {
            GameState._addToDeviceSet(set, child);
        }
    }

    wrapActions(actions = []) {
        let action : any;
        for (action of actions) {
            if (!action.type) {
                throw new Error('Actions require a type');
            }
            else if (['switch', 'interval', 'timeout', 'collection'].indexOf(action.type) < 0) {
                throw new Error('Invalid action type');
            }
            action.wrapped = [];
            for (const target of action.targets) {
                action.wrapped.push(this._wrapTarget(target));
            }
        }
    }

    _wrapTarget(target) {
        if (typeof target === 'function') {
            return target.bind(this);
        }
        else if (typeof target === 'object') {
            if (target.type === 'state') {
                return () => {
                    this['to' + target.target]();
                };
            }
            else if (target.type === 'data') {
                if (target.increment !== undefined) {
                    return () => {
                        const compressed = this.getCompressedState();
                        const newValue = compressed.data[target.id] + target.increment;
                        this.setData(target.id, newValue);
                    };
                }
                else {
                    return () => this.setData(target.id, target.value);
                }
            }
            // else if (target.type === 'conditional') {
            //     const evaluatedCondition = _eval(`module.exports = function() { return ${target.condition}}`);
            //     const wrappedCondition = this._wrapTarget(evaluatedCondition);
            //     const wrappedTrue = this._wrapTarget(target.true);
            //     const wrappedFalse = this._wrapTarget(target.false);
            //     return () => wrappedCondition() ? wrappedTrue() : wrappedFalse();
            // }
        }
    }

    getDeviceState(id) {
        const compressed = this.getCompressedState();
        return compressed.devices[id];
    }

    getActiveStateObj() {
        return this.states[this._stateMachine.state];
    }

    getActiveTimers() {
        const compressed = this.getCompressedState();
        const timers = compressed.actions || {};
        return Object.values(timers).filter((a : any) => a.type === 'interval' || a.type === 'timeout');
    }

    onAction(switchId) {
        const compressed = this.getCompressedState();
        
        let results = [];
        let handled = false;
        for(const actionLevel of compressed.actions) {
            for(const action of actionLevel) {
                if ((action.switches || []).indexOf(switchId) >= 0) {
                    handled = true;
                    results = results.concat(action.activate());
                }
            }
            if (handled) {
                break;
            }
        }
    }

    setData(id, value) {
        GameState.__setData(this, id, value);
    }

    static __setData(obj, id, value) {
        // depth first state device, then machine device
        for (const child of obj.children) {
            const dataSet = GameState.__setData(child, id, value);
            if (dataSet) {
                return true;
            }
        }

        // get active state device
        const activeState = obj.getActiveStateObj ? obj.getActiveStateObj() : null;
        if (activeState && activeState.data && activeState.data[id] !== undefined) {
            activeState.data[id] = value;
            return true;
        }
        else if (obj.data && obj.data[id] !== undefined) {
            obj.data[id] = value;
            return true;
        }
        else {
            return false;
        }
    }

    static _makeObj(candidate) {
        return candidate || {};
    }

    getCompressedState() {
        console.log('compressing');
        const result = {
            data: {},
            devices: {},
            actions: []
        };
        this._compress(this, result);
        result.actions.reverse();
        return result;
    }

    _compress(obj, result) {
        // merge our machine level properties
        _.assign(result.data, obj.data);
        _.assign(result.devices, obj.devices);
        // _.assign(result.actions, obj.actions);
        // result.actions = obj.actions.concat(result.actions);
        result.actions.push(obj.actions);

        // get active state device
        const activeState = obj.getActiveStateObj ? obj.getActiveStateObj() : null;
        if (activeState) {
            // merge our state level properties
            _.assign(result.data, activeState.data);
            _.assign(result.devices, activeState.devices);
            // _.assign(result.actions, activeState.actions);
            // result.actions = [activeState.actions].concat([result.actions]);
            result.actions.push(activeState.actions);
            for (const child of activeState.children) {
                this._compress(child, result);
            }
        }

        // recurse for children
        for (const child of obj.children) {
            this._compress(child, result);
        }
    }

    getOrigGameplayConfig(obj = this) {
        console.log('get orig');
        const clone = _.cloneDeep(obj);
        const picked = _.pick(clone, ['name', 'devices', 'data', 'states', 'designer', 'actions']);
        let state : any;
        for(state of Object.values(picked.states)) {
            state.children = state.children.map(child => this.getOrigGameplayConfig(child));
        }

        return picked;
    }

    addDevice(id : string, newDevice : any, stateName: string) {
        if (stateName) {
            this.states[stateName].devices[id] = newDevice;
        }
        else {
            this.devices[id] = newDevice;
        }
    }

    deleteDevice(id :string, stateName: string) {
        if (stateName) {
            delete this.states[stateName].devices[id];
        }
        else {
            delete this.devices[id];
        }
    }

    updateDevice(id, stateName : string) {
        if (stateName) {
            this.states[stateName].devices[id] = _.cloneDeep(this.states[stateName].devices[id]);
        }
        else {
            this.devices[id] = _.cloneDeep(this.devices[id]);
        }
    }

    addData(key: string, value: any) {
        this.data[key] = value;
    }

    deleteData(key : string) {
        delete this.data[key];
    }

    addState(name : string) {
        const isInit = Object.keys(this.states).length === 0;
        // const stateConfig = new State(name, isInit);
        this.states[name] = new State(name, isInit);
        this.updateStateMachine();
    }

    deleteState(name : string) {
        delete this.states[name];
    }

    addChild(stateName : string) {
        const child = new GameState({}, this.states[stateName]);
        this.states[stateName].children.push(child);
    }

    delete() {
        _.pull(this.parent.children, this);
    }

    onLeaveState(transition) {
        if (!this.states) {
            return;
        }
        // If we're leaving a state and that state has children, reset each child sm
        // to its 'init' state.
        for (const child of this.states[transition.from].children) {
            child.reset();
        }
    }

    addAction(stateName : string) {
        const action = {
            id: uuidv4(),
            name: 'Unnamed',
            type: 'switch',
            switches: [],
            targets: []
        };
        
        if (!stateName) {
            this.actions.push(new Action(action));
        }
        else {
            this.states[stateName].actions.push(action);
        }
    }

    deleteAction(id) {
        _.remove(this.actions, (action) => action.id === id);
    }

    getStates() {
        return this._stateMachine.allStates();
    }

    getAllowedStates() {
        return this.getStates().filter((s) => this._stateMachine.can(`to${s}`));
    }

    getCurrentState() {
        return this._stateMachine.state;
    }

    reset() {
        this._stateMachine.reset();
    }
}

export class State {
    name: String;
    init: boolean;
    to: String;
    devices: {};
    actions: {};
    data: {};
    children: any[];
    designer: any;

    constructor(name, isInit, to = '*', devices = {}, actions = [], data = {}, children = [], designer = {visible: true}) {
        this.name = name;
        this.init = isInit;
        this.to = to;
        this.devices = devices;
        this.actions = (actions || []).map((action) => new Action(action));
        this.data = data;
        this.children = children;
        this.designer = designer;
    }
}

export class Action {
    constructor(config : any) {
        this.id = config.id;
        this.name = config.name;
        this.type = config.type;
        this.switches = config.switches;
        this.targets = (config.targets || []).map((target) => {
            switch(target.type) {
                case 'state':
                default: // TODO: Remove this
                    return new StateTarget(target.target);
                break;
            }
        });
    }

    id: String;
    name: String;
    type: String;
    switches: String[];
    targets: Target[];
    wrapped: any[];

    activate(gameState : GameState) {
        for(const target of this.targets) {
            target.activate(gameState);
        }
    }
}

export class StateTarget implements Target {
    target : String
    constructor(target : String) {
        this.target = target;
    }

    activate(gameState : GameState) {
        const transitionName = `to${this.target}`;
        if (gameState._stateMachine.can(transitionName)) {
            gameState._stateMachine[transitionName]();
        }
        else {
            console.warn(`Transition ${transitionName} not allowed.`);
        }
    }
}

export interface Target {
    activate(gameState : GameState);
}
